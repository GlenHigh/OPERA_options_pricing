import matplotlib.pyplot as pltfrom matplotlib import cmfrom matplotlib.ticker import LinearLocatorimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdfrom datetime import datetimedef date_to_unix(date):    return int(datetime.strptime(date, '%Y/%m/%d %H:%M:%S').strftime("%s"))def today_unix():    return date_to_unix(datetime.today().strftime('%d/%m/%Y %H:%M:%S'))class PolynomialRegression:    def __init__(self,X,Y,order=-1, extrapolation=False):        if order<1:            order=len(X)-1        self.X=X        self.Y=Y        self.order=order        self.fit_status=False        self.beta=[]        self.extrapolate=extrapolation        self.min_eval=X[0]        self.max_eval=X[len(X)-1]    def fit_beta_coeff(self):        X_to_order =[np.ones(len(self.X)),self.X]        for i in range(2,self.order+1):            X_to_order.append(np.power(self.X,i))        X_to_order= np.transpose(X_to_order)        XtX_1 = np.linalg.inv(np.matmul(np.transpose(X_to_order),X_to_order))        self.beta= np.matmul(np.matmul(XtX_1,np.transpose(X_to_order)),self.Y)        self.fit_status=True    def fit(self):        self.fit_beta_coeff()    def change_order(self,order):        self.order=order        self.fit_status = False        self.fit_beta_coeff()        self.fit_status = True    #Evaluate a point    def evaluate_point(self, x):        if not self.extrapolate:            if not self.min_eval < x < self.max_eval:                return 0        X = [1,x]        for i in range(2,self.order+1):            X.append(np.power(x,i))        return np.dot(X,self.beta)    #Evaluate a vector of points    def evaluate_vector(self,X):        res=[]        for i in range(len(X)):            res.append(self.evaluate_point(X[i]))        return resclass Surface:    def __init__(self):        #calls        self.C_K=[]#vect of vect of strikes        self.C_min_K=0#window for viz        self.C_max_K = 0        self.C_imp_vol=[]#vect of vect of vols        self.C_bid = []  # vect of vect of bids        self.C_ask = []  # vect of vect of asks        self.C_T=[]#vect of T, my key        self.C_regressions=[]        #puts        self.P_K = []  # vect of vect of strikes        self.P_min_K=0#window for viz        self.P_max_K = 0        self.P_imp_vol = []  # vect of vect of vols        self.P_bid = []  # vect of vect of bids        self.P_ask = []  # vect of vect of asks        self.P_T = []  # vect of T, my key        self.P_regressions = []    def load_last_data(self):        c_data = pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Calls_AAPL_Last.csv')        p_data = pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Puts_AAPL_Last.csv')        today = today_unix()        self.C_max_K=max(c_data["Strike"])        self.C_min_K = min(c_data["Strike"])        self.P_max_K = max(p_data["Strike"])        self.P_min_K = min(p_data["Strike"])        #calls        for date in set(c_data['Date']):            filter=c_data['Date']==date            temp_c_k = c_data.where(filter)["Strike"]            temp_c_imp_vol = c_data.where(filter)["Implied Volatility"]            self.C_K.append(temp_c_k)            self.C_imp_vol.append(temp_c_imp_vol)            self.C_regressions.append(PolynomialRegression(temp_c_k,temp_c_imp_vol))            self.C_T.append(date_to_unix(date)-today)        # puts        for date in set(p_data['Date']):            filter = p_data['Date'] == date            temp_p_k = p_data.where(filter)["Strike"]            temp_p_imp_vol = p_data.where(filter)["Implied Volatility"]            self.P_K.append(temp_p_k)            self.P_imp_vol.append(temp_p_imp_vol)            self.P_regressions.append(PolynomialRegression(temp_p_k, temp_p_imp_vol))            self.P_T.append(date_to_unix(date) - today)    def build_viz(self,granularity_K=1):        c_axis_k=np.arange(self.C_min_K, self.C_max_K, granularity_K)        c_axis_t=self.C_T        c_vol_surface=[]        for i in range(len(c_axis_t)):            print(c_axis_k)            c_vol_surface.append(self.C_regressions[i].evaluate_vector(c_axis_k))        print(c_vol_surface)        c_axis_k, c_axis_t = np.meshgrid(c_axis_k, c_axis_t)        fig, ax = plt.subplots(subplot_kw={"projection": "3d"})        surf = ax.plot_surface(c_axis_k, c_axis_t, c_vol_surface, cmap=cm.coolwarm,linewidth=0, antialiased=False)        # Customize the z axis.        #ax.set_zlim(-1.01, 1.01)        ax.zaxis.set_major_locator(LinearLocator(10))        # A StrMethodFormatter is used automatically        ax.zaxis.set_major_formatter('{x:.02f}')        # Add a color bar which maps values to colors.        fig.colorbar(surf, shrink=0.5, aspect=5)        plt.show()####################### vvv TESTS vvv ######################surf=Surface()surf.load_last_data()surf.build_viz()X = [-1,0,1,2,3,4]Y=np.power(X,2)mod=PolynomialRegression(X,Y,2)mod.fit()print(mod.evaluate_vector([-3,1,0,1,3]))data=pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Calls_AAPL_Last.csv')print(data)fig, ax = plt.subplots(subplot_kw={"projection": "3d"})# Make data.K = np.arange(0, 130, 10)T = np.arange(0, 10, 1)K, T = np.meshgrid(K, T)R = np.sqrt(K**2 + T**2)Z = np.sin(R)# Plot the surface.surf = ax.plot_surface(K, T, Z, cmap=cm.coolwarm,                       linewidth=0, antialiased=False)# Customize the z axis.ax.set_zlim(-1.01, 1.01)ax.zaxis.set_major_locator(LinearLocator(10))# A StrMethodFormatter is used automaticallyax.zaxis.set_major_formatter('{x:.02f}')# Add a color bar which maps values to colors.fig.colorbar(surf, shrink=0.5, aspect=5)plt.show()