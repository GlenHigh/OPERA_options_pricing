import matplotlib.pyplot as pltfrom matplotlib import cmfrom matplotlib.ticker import LinearLocatorimport numpy as npimport matplotlib.pyplot as pltimport pandas as pddef date_to_unix(date):    return int(datetime.strptime(date, '%d/%m/%Y %H:%M:%S').strftime("%s"))class PolynomialRegression:    def __init__(self,X,Y,order=-1, extrapolation=False):        if order<1:            order=len(X)-1        self.X=X        self.Y=Y        self.order=order        self.fit_status=False        self.beta=[]        self.extrapolate=extrapolation        self.min_eval=X[0]        self.max_eval=X[len(X)-1]    def fit_beta_coeff(self):        X_to_order =[np.ones(len(self.X)),self.X]        for i in range(2,self.order+1):            X_to_order.append(np.power(self.X,i))        X_to_order= np.transpose(X_to_order)        XtX_1 = np.linalg.inv(np.matmul(np.transpose(X_to_order),X_to_order))        self.beta= np.matmul(np.matmul(XtX_1,np.transpose(X_to_order)),self.Y)        self.fit_status=True    def fit(self):        self.fit_beta_coeff()    def change_order(self,order):        self.order=order        self.fit_status = False        self.fit_beta_coeff()        self.fit_status = True    #Evaluate a point    def evaluate_point(self, x):        if not self.extrapolate:            if not self.min_eval < x < self.max_eval:                return 0        X = [1,x]        for i in range(2,self.order+1):            X.append(np.power(x,i))        return np.dot(X,self.beta)    #Evaluate a vector of points    def evaluate_vector(self,X):        res=[]        for i in range(len(X)):            res.append(self.evaluate_point(X[i]))        return resclass Surface:    def __init__(self):        #calls        self.C_K=[]#vect of vect of strikes        self.C_imp_vol=[]#vect of vect of vols        self.C_T=[]#vect of T, my key        self.C_regressions=[]        #puts        self.P_K = []  # vect of vect of strikes        self.P_imp_vol = []  # vect of vect of vols        self.P_T = []  # vect of T, my key        self.P_regressions = []        pass    def load_last_data(self):        c_data = pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Calls_AAPL_Last.csv')        p_data = pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Puts_AAPL_Last.csv')        #calls        for date in set(c_data['Date']):            filter=c_data['Date']==date            temp_c_k = c_data.where(filter)["Strike"]            temp_c_imp_vol = c_data.where(filter)["Implied Volatility"]            self.C_K.append(temp_c_k)            self.C_imp_vol.append(temp_c_imp_vol)            self.C_regressions.append(PolynomialRegression(temp_c_k,temp_c_imp_vol))            self.C_T.append(date_to_unix(date)-date_to_unix(now.strftime("%d/%m/%Y %H:%M:%S")))####################### vvv TESTS vvv ######################X = [-1,0,1,2,3,4]Y=np.power(X,2)mod=PolynomialRegression(X,Y,2)mod.fit()print(mod.evaluate_vector([-3,1,0,1,3]))data=pd.read_csv('/Users/glenhigh/Scrapping/OPERA_options_pricing/Market_data/Calls_AAPL_Last.csv')print(data)fig, ax = plt.subplots(subplot_kw={"projection": "3d"})# Make data.K = np.arange(0, 130, 10)T = np.arange(0, 10, 1)K, T = np.meshgrid(K, T)R = np.sqrt(K**2 + T**2)Z = np.sin(R)# Plot the surface.surf = ax.plot_surface(K, T, Z, cmap=cm.coolwarm,                       linewidth=0, antialiased=False)# Customize the z axis.ax.set_zlim(-1.01, 1.01)ax.zaxis.set_major_locator(LinearLocator(10))# A StrMethodFormatter is used automaticallyax.zaxis.set_major_formatter('{x:.02f}')# Add a color bar which maps values to colors.fig.colorbar(surf, shrink=0.5, aspect=5)plt.show()